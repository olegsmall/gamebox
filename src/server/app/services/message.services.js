/**
 * Created by: Peter Yablochkin
 * Created: 6 Oct 2018
 * Edited: 11 Oct 2018 by Peter Yablochkin
 *
 * @fileoverview Treats received data and executes DataBase CRUD queries for intern messaging system.
 * @module services/message.services
 * @requires message.model
 * @requires user.model
 */

// Importing models
const Message = require('../models/message.model');
const User = require('../models/user.model');

/**
 * Saves sent messages and it's references in user inbox/outbox fields.
 * By default message read status = false (what means that message was not read)
 * After message id is generated by mongoose schema, message_id is stored in inbox of receiver
 * and outbox of sender. This permits to save message if one person deletes message from his inbox/outobx
 *
 * @param req object - request info
 * @returns {Promise<*|Promise<json>>} A promise that returns json with created message if resolved,
 *    otherwise returns json with error message
 */
exports.sendMessage = function (req) {
  try {
    // Search receiver's id in DB by it's email
    return User.findOne({email: req.body.email}).select({password: 0}).then((user,err) => {
      if(err) {throw err;}
      if(user === null) {throw Error('User with email: ' + req.body.email + ' not found');}

      // Create message object
      let message = new Message({
        subject: req.body.subject,
        content: req.body.content,
        sender: req.user._id,
        receiver: user._id
      });

      // Save message id in receiver's outbox messages
      user.messages.inbox.push(message._id); //receiver
      user.save();

      // Save message id in sender's outbox messages
      req.user.messages.outbox.push(message._id);
      req.user.save();

      // Save message
      return message.save();
    });
  } catch (e) {
    throw Error('Error on message sending');
  }
};

/**
 * Gets specific message by ID.
 * On execution changes messages 'read' status to true - indicating that message was read
 *
 * @param req object - request info
 * @returns {Promise<*|Promise<json>>} A promise that returns json with created message if resolved,
 *    otherwise returns json with error message
 */
exports.getMessage = function (req) {
  try {
    return Message.findById(req.params.id).then((doc, err) => {
      if(err) {throw Error(err);}
      if(doc === null) {throw Error('Message not found');}
      // Change message status to true -> 'read'
      if(!doc.read) {doc.read = true;}
      doc.save();
      return doc;
    });
  } catch (e) {
    throw Error('Error on get message');
  }
};

/**
 * Gets all inbox messages from user inbox field.
 *
 * @param req object - request info
 * @returns {Promise<*|Promise<json>>} A promise that returns json with created message if resolved,
 *    otherwise returns json with error message
 */
exports.getInboxMessages = function (req) {
  let queryOptions = {}; // Mongoose-paginator query options
  let query = {}; // Mongoose query options

  req.query.page ? queryOptions.page = Number(req.query.page) : 1; //Page option
  req.query.limit ? queryOptions.limit = Number(req.query.limit) : 10; // Limit number of returning objects

  queryOptions.populate = {path: 'sender', select: 'firstName lastName'}; // Populate query fields

  try {
    return User.findById(req.user._id).select('messages.inbox').then((msg) => {
      let inbox = msg.messages.inbox;
      // add to query all messages ids form user inbox
      query = {_id: {$in: inbox}};
      return Message.paginate(query, queryOptions).then((docs) => {
        return docs;
      });
    });
  } catch (e) {
    throw Error('Error on get messages.');
  }
};

/**
 * Gets all outbox messages from user inbox field.
 *
 * @param req object - request info
 * @returns {Promise<*|Promise<json>>} A promise that returns json with created message if resolved,
 *    otherwise returns json with error message
 */
exports.getOutboxMessages = function (req) {
  let queryOptions = {}; // Mongoose-paginator query options
  let query = {}; // Mongoose query options

  req.query.page ? queryOptions.page = Number(req.query.page) : 1; //Page option
  req.query.limit ? queryOptions.limit = Number(req.query.limit) : 10; // Limit number of returning objects

  queryOptions.populate = {path: 'receiver', select: 'firstName lastName'}; // Populate query fields

  try {
    return User.findById(req.user._id).select('messages.outbox').then((msg) => {
      let outbox = msg.messages.outbox;
      // add to query all messages ids form user inbox
      query = {_id: {$in: outbox}};
      return Message.paginate(query, queryOptions).then((docs) => {
        return docs;
      });
    });
  } catch (e) {
    throw Error('Error on get messages.');
  }
};

/**
 * Gets and calculates all inbox messages with read status = false (unread messages).
 *
 * @param req object - request info
 * @returns object - number of unread messages
 */
exports.getNewMessages = function (req) {
  try {
    return Message.find({receiver: req.user._id, read: false}).then((msg, err) => {
      return msg.length;
    });
  } catch (e) {
    throw Error('Error at get new messages.');

  }
};

/**
 * Search message id in user inbox & outbox fields and delete it.
 * @param req object - request info
 * @returns {Promise<*|Promise<json>>} A promise that returns json with created message if resolved,
 *    otherwise returns json with error message
 */
exports.deleteMessage = function (req) {
  try {
    return User.findById(req.params.id).select('messages').then((messages, err) => {
      if(err) {throw err;}
      let inbox = messages.messages.inbox;
      let outbox = messages.messages.outbox;
      // Search for id in user inbox messages and delete it if it exists
      if(inbox.indexOf(req.body.message_id) > -1) {
        inbox.splice(inbox.indexOf(req.body.message_id), 1);
      }
      // Search for id in user outbox messages and delete it if it exists
      if (outbox.indexOf(req.body.message_id) > -1) {
        outbox.splice(outbox.indexOf(req.body.message_id), 1);
      }
      return messages.save();
    });
  } catch(e) {
    throw Error('Error at delete message');
  }
};